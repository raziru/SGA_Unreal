1.문제 설명
졸업 프로젝트를 위해 팀을 구성하려 합니다. 한 팀은 3명으로 구성되며, 모든 참가자는 먼저 같이 팀을 이루고 싶은 사람을 한 명씩 지명합니다. 이때, A가 B를, B가 C를, C가 A를 선택한 경우 A, B, C 세 사람이 한 팀이 됩니다. 예를 들어 각 참가자가 다음과 같이 선택하면 (1, 2, 3) 번 참가자가 한 팀을 이룹니다.

team_1001.png

각 참가자가 지목한 사람의 번호를 순서대로 담은 배열 vote가 solution 함수의 매개변수로 주어질 때, 총 몇 팀이 만들어지는지 return 하도록 solution 함수를 완성해주세요.

제한 사항
vote의 길이는 2 이상 1,000 이하입니다.
vote의 길이가 전체 참가자 수입니다.
vote의 원소는 1 이상 vote의 길이 이하인 자연수입니다.
모든 참가자는 1부터 (vote의 길이)까지 번호가 하나씩 붙어 있습니다.
vote의 첫 번째 원소는 1번 참가자가 선택한 사람의 번호, 두 번째 원소는 2번 참가자가 선택한 사람의 번호, ... 순으로 들어있습니다.
자기 자신을 선택한 사람은 없습니다.
만들어지는 팀이 없는 경우 0을 return 하세요.
입출력 예
vote	result
[2,3,1,3,4]	1
[5,4,2,3,1]	1
[2,3,4,1,6,7,5]	1
입출력 예 설명
입출력 예 #1
앞서 설명한 예와 같습니다

입출력 예 #2

3team_102.png

2번 참여자가 4번 참여자를, 4번 참여자가 3번 참여자를, 3번 참여자가 2번 참여자를 지목했으므로 2, 3, 4번 참여자가 한 팀을 이룹니다. 5번 참가자와 1번 참가자는 서로를 지목했지만, 한 팀은 3명으로 구성해야 하므로 둘은 팀을 이루지 못합니다.

입출력 예 #3

3team_103.png

5번, 6번, 7번 참가자가 팀을 이룹니다. 1번, 2번, 3번, 4번 참가자는 서로를 지목했으나 한 팀은 3명으로 구성해야 하므로 사람이 많아 넷은 팀을 이루지 못합니다.







































2.문제 설명
코딩 오디션 프로그램에 해커가 침투하여 일부 참가자의 점수를 조작하였습니다. 조사관으로 투입된 당신은, 해커가 조작한 점수에 어떤 패턴이 남은 것을 발견하였고, 아래와 같은 패턴을 띄는 조작된 점수를 제거하기로 하였습니다.

인접된 등수 사이의 점수차가 k번이상 반복되어 나온다면, 해당하는 인접된 등수는 모두 조작된 점수입니다.
이 때, 조작되지 않은 점수는 몇 개인지 구하려 합니다.
조작의 기준인 반복 횟수 k, 내림차순으로 정렬된 점수가 담긴 배열 score가 매개변수로 주어집니다. 이때, 조작되지 않은 점수의 개수를 return 하도록 solution 함수를 완성해주세요.

제한사항
k는 2이상 100,000이하인 정수입니다.
score는 길이가 1이상 500,000이하인 1차원 배열입니다.
score를 구성하는 원소는 0이상 2,000,000,000이하인 정수입니다.
score를 구성하는 원소는 내림차순으로 정렬되어 주어집니다.
score를 구성하는 원소에는 중복된 값이 없습니다.
입출력 예
k	score	result
3	[24,22,20,10,5,3,2,1]	3
2	[1300000000,700000000,668239490,618239490,568239490,568239486,518239486,157658638,157658634,100000000,100]	4
입출력 설명
입출력 예#1

등수	점수	앞 등수와의 점수차
1등	24	-
2등	22	2
3등	20	2
4등	10	10
5등	5	5
6등	3	2
7등	2	1
8등	1	1
1-2등, 2-3등, 5-6등 사이의 점수차가 2이며, 3회 반복됩니다. k=3 이므로, 1등, 2등, 3등, 5등, 6등의 점수는 모두 제거합니다. 남은 점수는 4등, 7등, 8등의 점수이므로 3을 return 합니다.

 
입출력 예#2

등수	점수	앞 등수와의 점수차
1등	1300000000	-
2등	700000000	600000000
3등	668239490	31760510
4등	618239490	50000000
5등	568239490	50000000
6등	568239486	4
7등	518239486	50000000
8등	157658638	360580848
9등	157658634	4
10등	100000000	57658634
11등	100	99999900
3-4등, 4-5등, 6-7등 사이의 점수차가 50000000으로, 3회 반복됩니다. 또한 8-9등, 5-6등 사이의 점수차가 4로, 2회 반복됩니다. k=2 이므로, 3등, 4등, 5등, 6등, 7등, 8등, 9등이 제거되어야 합니다. 제거하고 남은 점수는 아래와 같습니다.

등수	점수	앞 등수와의 점수차
1등	1300000000	-
2등	700000000	600000000
10등	100000000	57658634
11등	100	99999900
제거하고 남은 점수들을 살펴보면,
1-2등의 점수차가 600000000, 2-10등의 점수차가 600000000 입니다.
하지만 10등의 앞 등수는 2등이 아니라 제거된 9등이므로, 점수차 57658634가 여전히 유지됩니다. 즉, 중간에 몇 개의 점수가 제거되어도, 처음 정해진 앞 등수와의 점수차가 변하지는 않습니다. 따라서 4개의 점수가 남으며, 4를 return 해주어야 합니다.














3. 문제 설명
보조 배터리 n개를 구입하려면 최소 얼마가 필요한지 구하려 합니다. 보조 배터리 제조사로부터 다양한 제품들에 대한 견적을 받았고, 그 견적에는 '판매 단위'와 '단위 가격'(판매 단위만큼 구입할 때의 가격)이 적혀있습니다.

예를 들어 판매 단위가 4이고, 단위 가격이 35,000원인 제품이 있습니다. 이 배터리는 4의 배수 개(4개, 8개, 12개...등)씩 주문해야 하며, 3세트(12개)를 주문하면 105,000원을 내야 합니다.

구입할 배터리 수 n, 보조 배터리 제조사가 보내온 견적이 담긴 배열 battery가 매개변수로 주어질 때, 배터리를 n개 이상 구매하기 위해서 필요한 최소 비용을 return 하도록 solution함수를 완성해주세요.

제한사항
n은 10,000 이하인 자연수 입니다.
battery의 길이는 1이상 10,000 이하입니다.
battery의 원소는 [판매 단위, 단위 가격]을 나타냅니다.
판매 단위는 10,000이하인 자연수 입니다.
단위 가격은 200,000이하인 자연수 입니다.
입출력 예
n	battery	result
50	[[10,100000],[4,35000],[1,15000]]	450000
20	[[6,30000],[3,18000],[4,28000],[1,9500]]	108000
입출력 예 설명
입출력 예 #1
2번 제품을 12세트 주문하여 배터리 4 x 12 = 48개를 35,000 x 12 = 420,000원에 삽니다.
그리고 3번 제품을 2세트 주문하여 배터리 1 x 2 = 2개를 15,000 x 2 = 30,000원에 삽니다. 배터리 50개를 450,000에 구입했으며 이 때가 비용을 가장 적게 쓰는 경우입니다.

입출력 예 #2
1번 제품을 3세트를 주문하여 배터리 3 x 6 = 18개를 3 x 30,000 = 90,000원에 삽니다. 그리고 2번 제품을 1세트 주문하여 배터리 1 x 3 = 3개를 1 x 18,000 = 18,000원에 삽니다. 배터리 21개를 108,000원에 구입했으며 이 때가 비용을 가장 적게 쓰는 경우입니다. 20개가 필요하므로, 그 이상 주문하여도 상관 없습니다.







4. 문제 설명
철수는 XX항공사를 이용해 여행을 떠나려 합니다. XX항공사가 운행하는 공항은 총 n개이며, 각 공항에는 1부터 n까지 번호가 붙어 있습니다. 또, 비행기들은 서로 다른 두 공항 사이를 왕복해서 운항하며, 두 공항 사이를 이동할 때는 일정 시간이 소요됩니다.

철수는 1번 공항에서 출발해 k번 공항까지 이동해야 하는데, k번 공항으로 바로 갈 수 없다면, 다른 공항을 경유해서 이동해야 합니다.

XX항공사는 비행기를 이용할 경우, 이용한 항로에 따라 마일리지를 적립해 주는 제도를 운영하고 있습니다. 따라서 같은 목적지로 이동한다고 하더라도, 어떤 경로를 선택하느냐에 따라 더 많은 마일리지를 적립할 수도 있습니다.

철수는 물론, k번 공항까지 최대한 빨리 이동하고 싶기 때문에, 가능한 짧은 시간이 소요되는 경로를 선택하려 합니다. 그런데, 그런 경로가 여러 가지 일 경우에는 최대한 많은 마일리지를 적립하고 싶습니다.

다음은 항공사가 운행하는 공항 개수 n = 5, 목적지 k = 4인 예시입니다.

mileage_1.png

위 그림에서 원에 적힌 숫자는 공항 번호를 나타내며, 각 선분은 항로를 나타냅니다. 또, 선분에 적힌 숫자는 이동 시간 / 적립 마일리지를 나타냅니다. 예를 들어 1번 공항에서 2번 공항으로 이동할 때는 4시간이 걸리며, 3 마일리지가 적립됩니다.

위 예시에서 1번 공항에서 출발해 4번 공항으로 가는 가장 빠른 경로는 아래와 같이 2가지입니다.

1번 → 3번 → 4번
1번 → 5번 → 2번 → 4번
두 방법 모두 이동에 5시간이 걸리지만, 첫 번째 방법은 4 마일리지가 적립되며, 두 번째 방법은 5 마일리지가 적립됩니다.

따라서 1번 공항에서 출발해 4번 공항까지 가는데 걸리는 최단 시간은 5이며, 이때 쌓을 수 있는 최대 마일리지는 5가 됩니다.

항공기가 운항하는 공항 개수 n, 목적지 공항 번호 k, 각 항로의 정보를 담은 2차원 배열 paths가 매개변수로 주어질 때, 1번 공항에서 출발해 k번 공항으로 가는데 걸리는 최단 시간과 그때 적립할 수 있는 최대 마일리지를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
n은 2 이상 1,000 이하인 자연수입니다.
k는 2 이상 n 이하인 자연수입니다.
paths의 세로(행)길이는 1 이상 10,000 이하입니다.
paths의 각 행은 [a, b, c, d] 형태입니다.
a, b(1 ≤ a, b ≤ n, a != b)이며 이는 a 공항과 b 공항을 잇는 항로가 있다는 뜻입니다.
c(1 ≤ c ≤ 1,000, c는 자연수)는 두 공항사이를 이동하는데 걸리는 시간입니다.
d(1 ≤ c ≤ 1,000, d는 자연수)는 두 공항사이를 이동할 때 적립되는 마일리지입니다.
서로 다른 두 공항 사이를 직접 운항하는 노선은 정확히 1개입니다.
같은 운항 노선 정보가 중복해서 주어지지 않습니다.
임의의 두 공항간에 항상 이동 가능한 경로가 존재합니다.
return 하는 배열은 [최단 시간, 최대 마일리지] 순서여야 합니다.
입출력 예
n	k	paths	result
5	4	[[1,5,1,1],[1,2,4,3],[1,3,3,2],[2,5,2,1],[2,4,2,3],[3,4,2,2]]	[5,5]
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.