대입에서 lvalue는 빈칸이고 rvalue는 내용이다. 
선언과 동시에 초기화되어야하는 것은 const와 &를 사용한 reference이다.
const와 reference는 절대 빈칸이어서는 안된다. ""은 빈칸이 아니다.

선언 *와 연산의 *는 다르다. 선언*는 포인터고 연산의 *는 역참조를 반환한다.

선언&는 원본 참조하는 변수고 연산의 &는 함수의 주소를 반환한다.

*와 &는 상쇄된다.

malloc, free는 생성자 소멸자 호출을 안해준다. 사이즈나 유효여부도 확인안해준다.
new, delete는 생성자 소멸자를 호출한다.

이차원배열은 stack에서는 전부 연속적인 주소지만 heap에서는 같은 배열에 소속된 객체들만 연속이고 배열끼리는 연속적이지 않다.

기본, 복제, 대입

복제 생성자
클래스를 반환할 때 생성된다.
얕은 복사는 클래스에 동적할당된 맴버변수가 있으면 그 변수를 건드려버리기때문에 사용할때 문제가 생긴다.
복제 생성자를 직접 재정의해줘야한다.

dynamic cast
rtti, virtual 함수를 보고 되는지 여부를 판단한다.
static cast
int->float등 일반적 형변환
const cast
상수를 변수로 변경하는 형변환//잘안쓴다.

virtual 함수는 런타임때 테이블이 생기며 upcasting으로 생성된 객체가 override된 함수를 사용할 수 있게 해준다.
최상위 class의 함수가 virtual이면 그 아래 클래스의 같은 함수들은 전부 virtual이 된다.
virtual 소멸자를 안쓰면 부모 클래스만 지우고 지나가기 때문에 자식클래스의 메모리는 남아버려서 메모리 누수가 생긴다.